# George Velonis' ePortfolio

Welcome to my ePortfolio!

Here you will find some reflections on my experiences as a stupid and in my professional life, narratives describing my processes, and examples of my work.  I will link to specific pieces as relevent, but for the complete work see my [CS-499 Repository](https://github.com/gvelonis/CS-499). The complete repository includes sample API calls, database deployment scripts, sample data, as well as the original artifacts for posterity.

### Professional Self-Assessment

Throughout completing my program I had a chance to work with a few different languages and technologies, which gave me a chance to see what I found interesting or not and shaped the path I want to follow in my career.  Although what I have included in my ePortfolio is all in python, I worked extensively with C++ and Java as well.  Courses like software development life cycle and software testing and quality assurance gave me an understanding on the way developers work together to collaborate in a team environment and communicate with project stakeholders in a professional environment.  Other courses outside of the major also gave me good experiences with collaboration and communication by requiring me to work with other students and produce a wide range of media to share information quickly and effectively.  I got to work with openGL which was informative but in a way disappointing – I learned that I hate graphics programming so a career in game development probably isn’t a good path for me. Most importantly I got to study SQL and databases a lot with 5 different database related courses completed, which is the path I will focus on going forward in my professional development.  I currently work for a company known for their databases and have real world experience working with a  variety of RDBMS platforms. Now that I also have an academic background to support my experiences I an poised to be a productive new member of a team working with them.
	
To showcase my skills in the data structures and algorithms category I took a simple athletics roster program from one of my first courses that was meant to showcase my usage of the python dict type and upgraded it to use a doubly linked list instead of a dict. That way I was able to have multiple data fields associated with each node by creating a class to represent player objects and embedding it in each node. I then implemented a few different sorting algorithms to sort the list by different fields.
	
For the software engineering and design category, databases, and security category I took the final from my most recent course, which was also my most advanced program at the time, and further improved upon it to produce the most complete, polished, and feature rich program I have written so far.  The original artifact was a mess that met all the objectives of that assignment but wasn’t thoughtfully designed at all. The first step in improving it was to redesign it to meet software design standards, specifically to split the one large program in to two classes and two separate programs with their own functions. The first class is a basic database connection class that can be applied to any mongodb connection, the second class extends the first and contains functions specific to the market database being worked with. One of the programs is a ReST API to interact with the database, the other is a command line interface to interact with the database.  After improving the design and re-engineering it, I worked on enhancing the security by adding in database access control.  The database is now secured, the user the market interface class uses only has read/write access and only to that database. It has only the privileges it needs to perform its function and nothing more. Furthermore, I improved the program by increasing the error handling and validating user input before passing it to the database to prevent injection attacks.

### Code Review

See me holding a code review of my design/database artifact before implementng the updates. It is hosted on youtube [here!](https://youtu.be/8JxVkJhRM8c)

### Data Structures/Algorithms Artifact

See my implementation of a doubly-linked list and several sorting algorithms for an athletics team [roster](https://github.com/gvelonis/CS-499/blob/master/Roster.py) as a part of the greater [CS-499 repository](https://github.com/gvelonis/CS-499).

### Software Design/Engineering and Databases Artifact

My implementation of a [ReST API](https://github.com/gvelonis/CS-499/blob/master/MarketAPI.py) and [CLI program](https://github.com/gvelonis/CS-499/blob/master/MarketCLI.py) for interacting with a mongoDB database can be found in the [CS-499 repository](https://github.com/gvelonis/CS-499) as well.

### Software Design/Engineering Narrative

The artifact I chose to enhance for the Software Design/Engineering aspect of the capstone requirement was my final from CS-340 Client Server Development, completed February 2020. It was a monolithic file that contained all the project requirements but not in an organized way. It was a ReST API, command line interface, and multiple levels of functions to interact with a mongo database. I selected it because it represents the most complete work I still had but also represented a work that had a lot of functionality but was not well designed.
	
To improve it I split the single large file in to four separate files, two main applications and two classes. First is the ReST API which can now be run on its own and only contains the API calls, second the command line interface which is just a menu. They both are used to access the functions of the MarketDbIfc class which does the heavy lifting of the project. It contains all the functions needed for the main applications, but they are specific to the documents found in the market database. That class uses two instances of the MongoIfc class in the fourth file, which contains basic functions for accessing a mongodb database with generic documents. The majority of the work done was refactoring an adding comments, the logic itself is unchanged. I also created a shell script to initialize the market database, create indices, and import sample data.
	
I’ve definitely met the course objective I intended to with this artifact – CS-499-04. By using an object oriented design and widely used tools in the form of MongoDB to give the user access to data useful to the finance industry, I demonstrated the ability to use well-founded and innovative techniques, skills, and tools in computing practices for the purpose of implementing computer solutions that deliver value and accomplish industry-specific goals.
	
The process of implementing the enhancements was straightforward enough, but it was also new to me.  It was the first time I created and used my own objects in python, so I had to teach myself how to do that. I also struggled at first trying to create overloaded definitions, but a little research showed that in python you can’t overload definitions but can use default values and conditional logic instead.  In the __init__ method for the MongoIfc class I use default values for the host/port, and in the read_doc method for the MarketDbIfc class I use conditional logic to see if a second argument was passed. The other challenge I faced was in getting a development environment going, not because of technical issues but due to indecisiveness and too many options. I originally spun up a debian VM and got PyCharm, mongod, PyMongo, and bottle installed and setup. I did my code review on that but due to resolution and performance issues I realized it would slow me down too much when it came time to make the changes. I then had to decide between Windows on my gaming PC or Windows on my laptop but wanted to stick to developing on Linux so I had to take the time to install a Ubuntu derivative on my laptop and reconfigure my development environment.
  
### Data Structures/Algorithms Narrative

This artifact is a piece of my final going back to CS-200. It is a simple program to input a roster of athletes for a sports team, then output them. It was originally made to show off my use of the basic list and dict data types in python, so it seems fitting that I used it to show off my use of advanced data structures and algorithms.
	
To demonstrate my ability to understand data structures, I created a player class to store data about the athletes including name and position, instead of the previous simple dict that only stored jersey number and rating.  I then created generic classes for a doubly linked list and it’s nodes, then created a roster class to extend the DlinkedList class to this meet this specific application’s requirements.  I then wrote functions to sort the roster by each piece of athlete data, mostly using bubble sort but one with insertion sort to show my ability to implement and understand different algorithms. Before starting the enhancements, I initialized the project with git to start using version control and linked it to my github so now I have a local and remote repository for it.
	
This artifact shows my ability to meet course outcomes CS-499-03 and CS-499-04. By implementing multiple algorithms and using object oriented design principles I have shown that I can apply appropriate computer science practice and standards and that I can use various techniques and tools to implement solutions that deliver real value.
	
I definitely learned a lot more about python when enhancing this artifact. I originally thought this aspect would be a relatively simple task of finding a reference implementation of a doubly linked list and sorting algorithms online somewhere and putting it to use in my application; instead I found a lot of challenges. Originally I implemented the player class as a type of node instead of just the payload for a node and ran in to struggles writing the swap_node function. The sorting algorithms were also challenging because of the way I had structured my roster class. The bubble sort algorithms work in place on the roster, but I couldn’t figure out how to do that for the insertion sort algorithm. So instead it creates a new roster and returns it, which means when it is called from main it needs to have an assignment operator that the rest of the sorting funtion calls don’t need. If I had more time to put in to it I would try to refactor so that they all behave the same way, either operating on the roster in place or making a copy of it and returning the modified copy to then be assigned in main. I learned a lot about the python built in __setattr__ and __iter__ methods I needed to define when creating the classes. I also learned a lot about the self keyword when struggling with how to do insertion sort on the in place roster instead of creating a new one.
  
### Database Narrative

For this artifact I continued working with the final from CS-340.  It is a ReST and command line interface for a mongo database with data on stocks and companies. Previously I had improved the software design by moving the monolothic file in two two classes and two programs.
	
Before enhancing the artifact it was already my most advanced database work so it was only natural to build upon that.  I did so by adding authentication to the database and creating scripts to create the database, users, and import data.
	
I definitely met the database course objective with this enhancement and probably the security objective as well. My plan for final improvements is to improve the error handling, which will definitely put me in place for meeting the security enhancement.
	
I learned a lot about certificate authentication, and certificate security in general in this module.  My original plan was to use x.509 authentication to secure my database, but after a lot of research I realized that it isn’t worth it with limited resources because certificates are expensive! Despite not doing my original plan I still feel like I met my goals because I learned everything I need to know to implement certificate authentication I just lack the actual certificates.
